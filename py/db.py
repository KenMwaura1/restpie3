#!/usr/bin/python
# -*- coding: utf-8 -*-

"""db.py: Models and functions for accessing the database
   - using peewee orm
   - preferably have all SQL in this file

Author: Tomi.Mickelsson@iki.fi

http://docs.peewee-orm.com/en/latest/peewee/querying.html
http://docs.peewee-orm.com/en/latest/peewee/playhouse.html#postgres-ext
"""

from peewee import *
from playhouse.shortcuts import model_to_dict
from playhouse.postgres_ext import PostgresqlExtDatabase, ArrayField, BinaryJSONField, BooleanField, JSONField
from flask import abort
import config

import logging
log = logging.getLogger("db")

database = PostgresqlExtDatabase(config.DATABASE_NAME,
        user=config.DATABASE_USER, password=config.DATABASE_PASSWORD,
        host=config.DATABASE_HOST, port=5432)


# --------------------------------------------------------------------------
# Base model and common methods

class BaseModel(Model):
    """Base class for all database models."""

    # exclude these fields from the serialized dict
    EXCLUDE_FIELDS = []

    def serialize(self):
        """Serialize the model into a dict."""
        return model_to_dict(self, recurse=False, exclude=self.EXCLUDE_FIELDS)

    class Meta:
        database = database


def get_object_or_404(model, **kwargs):
    """Retrieve a single object or abort with 404."""

    try:
        return model.get(**kwargs)
    except model.DoesNotExist:
        log.warning("NO OBJECT {} {}".format(model, kwargs))
        abort(404)

def get_object_or_none(model, **kwargs):
    """Retrieve a single object or return None."""

    try:
        return model.get(**kwargs)
    except model.DoesNotExist:
        return None


# --------------------------------------------------------------------------
# USER

class User(BaseModel):

    # Should user.id be an integer or uuid? Both have pros and cons.
    # Since user.id is sensitive data, I selected uuid here.
    id = UUIDField(primary_key=True)
    id.auto_increment = True # is auto generated by server

    email = TextField()
    password = TextField()
    first_name = TextField()
    last_name = TextField()
    role = TextField()
    tags = ArrayField(TextField)

    created = DateTimeField()
    modified = DateTimeField()

    EXCLUDE_FIELDS = [password] # never expose password


    def is_superuser(self):
        return self.role == "superuser"

    def full_name(self):
        return "{} {}".format(self.first_name, self.last_name or '')

    def is_role_atleast(self, role):
        """Checks that my role is same or above the given role. Assumes a
        simple role model where roles can be arranged from lowest
        access to highest access level."""

        if not role:
            return True
        levels = {"readonly":1, "editor":2, "admin":3, "superuser":4}
        try:
            return levels[self.role] >= levels[role]
        except:
            return False

    def serialize(self):
        """Serialize this object to dict/json."""

        d = super(User, self).serialize()

        # add extra data
        d["fullname"] = self.full_name()
        d["tags"] = self.tags or [] # never None
        return d

    def __str__(self):
        return "<User {}, {}, role={}>".format(self.id,
                self.email, self.role)

    class Meta:
        db_table = 'users'


def get_user(uid):
    """Return user object or throw."""
    return get_object_or_404(User, id=uid)


def get_user_by_email(email):
    """Return user object or None"""

    if not email:
        return None
    try:
        return User.select().where(User.email == email).get()
    except User.DoesNotExist:
        return None


def query_users(page=0, limit=1000, search=None):
    """Return list of users. Desc order"""

    page = int(page)
    limit = int(limit)

    q = User.select()
    if search:
        search = "%"+search+"%"
        q = q.where(User.first_name ** search | User.last_name ** search |
                User.email ** search)
    q = q.paginate(page, limit).order_by(User.id.desc())
    return q


# --------------------------------------------------------------------------

if __name__ == '__main__':

    # quick adhoc tests
    logging.basicConfig(level=logging.DEBUG)

    u = User(first_name="tomi")
    u.email = "myemail@example.org"
    u.save(force_insert=True)
    print(u)

    print(list(query_users(0, "10", ".com")))

